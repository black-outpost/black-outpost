<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid-Based Skill Tree Editor</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(20,20,30,0.9) 100%);
            min-height: 100vh;
            color: #e0e6ed;
            overflow-x: hidden;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 2;
        }

        .nav-bar {
            background: linear-gradient(135deg, rgba(15,23,42,0.9) 0%, rgba(30,41,59,0.8) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(71, 85, 105, 0.3);
            border-radius: 12px;
            padding: 16px 24px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .nav-title {
            font-size: 18px;
            font-weight: 600;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 12px;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.5px;
        }

        .nav-title::before {
            content: "🌳";
            color: #10b981;
        }

        .nav-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            background: linear-gradient(135deg, rgba(71, 85, 105, 0.8) 0%, rgba(51, 65, 85, 0.9) 100%);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            font-family: 'JetBrains Mono', monospace;
        }

        .btn:hover {
            background: linear-gradient(135deg, rgba(71, 85, 105, 1) 0%, rgba(51, 65, 85, 1) 100%);
            border-color: rgba(148, 163, 184, 0.4);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.8) 0%, rgba(220, 38, 38, 0.9) 100%);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.8) 0%, rgba(5, 150, 105, 0.9) 100%);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .editor-layout {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            gap: 20px;
            height: calc(100vh - 140px);
        }

        .sidebar, .properties-panel {
            background: linear-gradient(135deg, rgba(15,23,42,0.9) 0%, rgba(30,41,59,0.8) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(71, 85, 105, 0.3);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }

        .sidebar-header, .panel-header {
            background: linear-gradient(135deg, rgba(30,41,59,0.9) 0%, rgba(51,65,85,0.8) 100%);
            padding: 16px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.4);
        }

        .sidebar-title, .panel-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
            letter-spacing: 0.5px;
        }

        .tree-selector {
            padding: 16px;
        }

        .tree-tabs {
            display: grid;
            gap: 8px;
        }

        .tree-tab {
            background: linear-gradient(135deg, rgba(30,41,59,0.6) 0%, rgba(51,65,85,0.4) 100%);
            border: 1px solid rgba(71, 85, 105, 0.3);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 500;
            color: #94a3b8;
        }

        .tree-tab:hover {
            border-color: rgba(148, 163, 184, 0.5);
            color: #e2e8f0;
        }

        .tree-tab.active {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3) 0%, rgba(5, 150, 105, 0.2) 100%);
            border-color: rgba(16, 185, 129, 0.5);
            color: #10b981;
        }

        .node-palette {
            padding: 16px;
            border-top: 1px solid rgba(71, 85, 105, 0.3);
        }

        .palette-section {
            margin-bottom: 20px;
        }

        .palette-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #64748b;
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .node-templates {
            display: grid;
            gap: 8px;
        }

        .node-template {
            background: linear-gradient(135deg, rgba(30,41,59,0.6) 0%, rgba(51,65,85,0.4) 100%);
            border: 1px solid rgba(71, 85, 105, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 8px;
            draggable: true;
            user-select: none;
        }

        .node-template:hover {
            border-color: rgba(148, 163, 184, 0.5);
            transform: translateY(-1px);
        }

        .node-template:active {
            cursor: grabbing;
        }

        .canvas-container {
            background: linear-gradient(135deg, rgba(15,23,42,0.9) 0%, rgba(30,41,59,0.8) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(71, 85, 105, 0.3);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .canvas-header {
            background: linear-gradient(135deg, rgba(30,41,59,0.9) 0%, rgba(51,65,85,0.8) 100%);
            padding: 16px;
            border-bottom: 1px solid rgba(71, 85, 105, 0.4);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .canvas-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .canvas-tools {
            display: flex;
            gap: 8px;
        }

        .tool-btn {
            background: linear-gradient(135deg, rgba(71, 85, 105, 0.6) 0%, rgba(51, 65, 85, 0.7) 100%);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #94a3b8;
        }

        .tool-btn:hover {
            background: linear-gradient(135deg, rgba(71, 85, 105, 0.8) 0%, rgba(51, 65, 85, 0.9) 100%);
            color: #e2e8f0;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3) 0%, rgba(5, 150, 105, 0.2) 100%);
            border-color: rgba(16, 185, 129, 0.5);
            color: #10b981;
        }

        .tree-canvas {
            position: relative;
            width: 100%;
            height: calc(100% - 60px);
            overflow: auto;
        }

        .tier-container {
            position: relative;
            width: 100%;
            min-height: 100%;
            padding: 20px;
        }

        .tier-section {
            position: relative;
            width: 100%;
            height: 500px;
            border-bottom: 2px dashed rgba(148, 163, 184, 0.3);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tier-content {
            position: relative;
            width: 550px;
            height: 500px;
        }

        .tier-header {
            position: absolute;
            top: 10px;
            left: 20px;
            background: linear-gradient(135deg, rgba(15,23,42,0.9) 0%, rgba(30,41,59,0.8) 100%);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #f1f5f9;
            border: 1px solid rgba(71, 85, 105, 0.3);
            z-index: 5;
        }

        .add-tier-btn {
            display: block;
            margin: 20px auto;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.8) 0%, rgba(5, 150, 105, 0.9) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #f1f5f9;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }

        .add-tier-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.4);
        }

        /* Grid system */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.5;
            z-index: 1;
        }

        .grid-cell {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-sizing: border-box;
        }

        .grid-cell.occupied {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .grid-cell.hover {
            background: rgba(245, 158, 11, 0.2);
            border-color: rgba(245, 158, 11, 0.5);
        }

        .node-template.selected {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3) 0%, rgba(5, 150, 105, 0.2) 100%);
            border-color: rgba(16, 185, 129, 0.5);
            color: #10b981;
        }

        .grid-cell.clickable {
            cursor: crosshair;
        }

        .grid-cell.clickable:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.6);
        }

        /* Node styles */
        .skill-node {
            position: absolute;
            cursor: move;
            user-select: none;
            transition: all 0.3s ease;
            z-index: 10;
            border-radius: 8px;
        }

        .skill-node.selected {
            filter: drop-shadow(0 0 10px rgba(16, 185, 129, 0.6));
            z-index: 15;
        }

        .skill-node.dragging {
            z-index: 20;
            transform: scale(1.05);
        }

        /* Small nodes (1 grid cell = 50x50px) */
        .node-small {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.8) 0%, rgba(5, 150, 105, 0.9) 100%);
            border: 2px solid #10b981;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            font-weight: 600;
            color: #f1f5f9;
        }

        /* Medium rectangular nodes (2 grid cells = 100x50px) */
        .node-medium-rect {
            width: 100px;
            height: 50px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.8) 0%, rgba(217, 119, 6, 0.9) 100%);
            border: 2px solid #f59e0b;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 500;
            color: #f1f5f9;
            text-align: center;
            padding: 4px;
        }

        /* Large circular nodes (4 grid cells = 100x100px) */
        .node-large-circle {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.8) 0%, rgba(220, 38, 38, 0.9) 100%);
            border: 3px solid #ef4444;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            font-weight: 500;
            color: #f1f5f9;
            text-align: center;
            padding: 8px;
        }

        /* Large rectangular nodes (4 grid cells = 200x50px) */
        .node-large-rect {
            width: 200px;
            height: 50px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.8) 0%, rgba(124, 58, 237, 0.9) 100%);
            border: 2px solid #8b5cf6;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            font-weight: 500;
            color: #f1f5f9;
            text-align: center;
            padding: 4px 8px;
        }

        /* Segmented small nodes */
        .node-segmented {
            position: relative;
        }

        .segment {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .segment-2 {
            width: 25px;
            height: 50px;
        }

        .segment-2.left {
            left: 0;
            border-radius: 25px 0 0 25px;
        }

        .segment-2.right {
            right: 0;
            border-radius: 0 25px 25px 0;
        }

        .segment-4 {
            width: 25px;
            height: 25px;
        }

        .segment-4.top-left {
            top: 0;
            left: 0;
            border-radius: 25px 0 0 0;
        }

        .segment-4.top-right {
            top: 0;
            right: 0;
            border-radius: 0 25px 0 0;
        }

        .segment-4.bottom-left {
            bottom: 0;
            left: 0;
            border-radius: 0 0 0 25px;
        }

        .segment-4.bottom-right {
            bottom: 0;
            right: 0;
            border-radius: 0 0 25px 0;
        }

        /* Starter node special styling */
        .starter-node {
            border: 3px solid #f59e0b !important;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.9) 0%, rgba(217, 119, 6, 1) 100%) !important;
        }

        .starter-node::after {
            content: "★";
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
            color: #fbbf24;
        }

        /* Connection lines */
        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .connection-line {
            stroke: rgba(148, 163, 184, 0.6);
            stroke-width: 2;
            fill: none;
        }

        .connection-arrow {
            stroke: rgba(148, 163, 184, 0.8);
            stroke-width: 2;
            fill: none;
        }

        .connection-exclude {
            stroke: rgba(239, 68, 68, 0.8);
            stroke-width: 2;
            stroke-dasharray: 8,4;
            fill: none;
        }

        .properties-content {
            padding: 16px;
            height: calc(100% - 60px);
            overflow-y: auto;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: #94a3b8;
            margin-bottom: 6px;
            display: block;
            text-transform: uppercase;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 6px 10px;
            background: linear-gradient(135deg, rgba(30,41,59,0.6) 0%, rgba(51,65,85,0.4) 100%);
            border: 1px solid rgba(71, 85, 105, 0.4);
            border-radius: 6px;
            color: #f1f5f9;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        .form-textarea {
            min-height: 50px;
            resize: vertical;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: rgba(16, 185, 129, 0.5);
        }

        .success-message, .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            font-weight: 500;
            z-index: 1001;
            max-width: 400px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(71, 85, 105, 0.3);
        }

        .success-message {
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.9) 0%, rgba(16, 185, 129, 0.8) 100%);
            color: #a7f3d0;
            border-color: rgba(16, 185, 129, 0.3);
        }

        .error-message {
            background: linear-gradient(135deg, rgba(153, 27, 27, 0.9) 0%, rgba(127, 29, 29, 0.8) 100%);
            color: #fecaca;
            border-color: rgba(239, 68, 68, 0.3);
        }

        @media (max-width: 1400px) {
            .editor-layout {
                grid-template-columns: 250px 1fr 280px;
            }
        }

        @media (max-width: 1200px) {
            .editor-layout {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
                height: auto;
            }
            
            .sidebar, .properties-panel {
                height: auto;
                max-height: 300px;
            }
            
            .tree-canvas {
                height: 600px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav-bar">
            <div class="nav-title">
                SKILL TREE EDITOR
            </div>
            <div class="nav-actions">
                <button class="btn" onclick="exportTree()">EXPORT</button>
                <button class="btn" onclick="importTree()">IMPORT</button>
                <button class="btn btn-success" onclick="saveTree()">SAVE TREE</button>
                <a href="admin-dashboard.html" class="btn" id="backToDashboard">DASHBOARD</a>
                <a href="index.html" class="btn btn-danger" onclick="logout()">LOGOUT</a>
            </div>
        </nav>

        <div class="editor-layout">
            <!-- Left Sidebar -->
            <div class="sidebar">
                <div class="sidebar-header">
                    <div class="sidebar-title">SKILL TREES</div>
                </div>
                <div class="tree-selector">
                    <div class="tree-tabs" id="treeTabs">
                        <div class="tree-tab active" data-tree="strength">STRENGTH</div>
                        <div class="tree-tab" data-tree="vitality">VITALITY</div>
                        <div class="tree-tab" data-tree="speed">SPEED</div>
                        <div class="tree-tab" data-tree="defense">DEFENSE</div>
                        <div class="tree-tab" data-tree="reiatsu">REIATSU</div>
                        <div class="tree-tab" data-tree="hakuda">HAKUDA</div>
                        <div class="tree-tab" data-tree="weaponship">WEAPONSHIP</div>
                        <div class="tree-tab" data-tree="tamashi">TAMASHI</div>
                        <div class="tree-tab" data-tree="magic">MAGIC</div>
                        <div class="tree-tab" data-tree="nazo">NAZO</div>
                    </div>
                </div>
                <div class="node-palette">
                    <div class="palette-section">
                        <div class="palette-title">Node Types</div>
                        <div class="node-templates">
                            <div class="node-template" data-type="small" data-size="1">
                                <span style="color: #10b981;">●</span>
                                Small Node (1x1)
                            </div>
                            <div class="node-template" data-type="small-segmented-2" data-size="1">
                                <span style="color: #10b981;">◐</span>
                                Split Node (1x1)
                            </div>
                            <div class="node-template" data-type="small-segmented-4" data-size="1">
                                <span style="color: #10b981;">◔</span>
                                Quad Node (1x1)
                            </div>
                            <div class="node-template" data-type="medium-rect" data-size="2">
                                <span style="color: #f59e0b;">▬</span>
                                Med Rect (2x1)
                            </div>
                            <div class="node-template" data-type="large-circle" data-size="4">
                                <span style="color: #ef4444;">◯</span>
                                Large Circle (2x2)
                            </div>
                            <div class="node-template" data-type="large-rect" data-size="4">
                                <span style="color: #8b5cf6;">▭</span>
                                Large Rect (4x1)
                            </div>
                        </div>
                    </div>
                    <div class="palette-section">
                        <div class="palette-title">Tools</div>
                        <div style="display: grid; gap: 8px;">
                            <button class="btn" onclick="setTool('connect')" style="font-size: 11px;">Connect Nodes</button>
                            <button class="btn" onclick="setTool('exclude')" style="font-size: 11px;">Add Exclusion</button>
                            <button class="btn" onclick="toggleGrid()" style="font-size: 11px;">Toggle Grid</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Canvas -->
            <div class="canvas-container">
                <div class="canvas-header">
                    <div class="canvas-title" id="canvasTitle">STRENGTH TREE</div>
                    <div class="canvas-tools">
                        <button class="tool-btn active" onclick="setTool('select')">SELECT</button>
                        <button class="tool-btn" onclick="addTier()">ADD TIER</button>
                        <button class="tool-btn" onclick="previewTree()">PREVIEW</button>
                        <button class="tool-btn" onclick="clearTier()">CLEAR TIER</button>
                        <button class="tool-btn btn-danger" onclick="resetTree()">RESET</button>
                    </div>
                </div>
                <div class="tree-canvas" id="treeCanvas">
                    <button class="add-tier-btn" onclick="addTier()">+ ADD NEW TIER</button>
                    <div class="tier-container" id="tierContainer">
                        <!-- Tiers will be dynamically generated here -->
                    </div>
                    <svg class="connection-svg" id="connectionSvg">
                        <!-- Connection lines will be drawn here -->
                    </svg>
                </div>
            </div>

            <!-- Right Properties Panel -->
            <div class="properties-panel">
                <div class="panel-header">
                    <div class="panel-title">NODE PROPERTIES</div>
                </div>
                <div class="properties-content" id="propertiesContent">
                    <div style="text-align: center; color: #64748b; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin-top: 40px;">
                        SELECT A NODE TO EDIT
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
        import { getFirestore, doc, getDoc, setDoc, collection, addDoc, getDocs } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';
        
        const firebaseConfig = {
            apiKey: "AIzaSyBurBHVh1tNQ5LdPPYEaynkiwm_nJQbM7o",
            authDomain: "bleach-black-outpost.firebaseapp.com",
            projectId: "bleach-black-outpost",
            storageBucket: "bleach-black-outpost.firebasestorage.app",
            messagingSenderId: "201204368777",
            appId: "1:201204368777:web:c2a34d61acb46e7b494d58",
            measurementId: "G-SBD3766NQ6"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        
        window.firebase = {
            db: db,
            doc: doc,
            getDoc: getDoc,
            setDoc: setDoc,
            collection: collection,
            addDoc: addDoc,
            getDocs: getDocs
        };
        
        window.firebaseReady = true;
    </script>

    <script>
        // Global variables
        let currentUser = null;
        let currentTree = 'strength';
        let currentTool = 'select';
        let selectedNode = null;
        let connectingFrom = null;
        let treeData = {};
        let gridVisible = true; // Grid is visible by default
        let selectedNodeType = null; // For click-to-place functionality

        // Grid constants
        const GRID_SIZE = 50; // Each grid cell is 50x50 pixels
        const GRID_COLS = 11; // 11 columns per tier (to have center)
        const GRID_ROWS = 10; // 10 rows per tier

        // Initialize
        window.addEventListener('load', function() {
            const checkFirebase = setInterval(() => {
                if (window.firebaseReady) {
                    clearInterval(checkFirebase);
                    loadUserData();
                    initializeEditor();
                }
            }, 100);
        });

        function showMessage(message, type = 'success') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `${type}-message`;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.remove();
            }, 3000);
        }

        async function loadUserData() {
            const urlParams = new URLSearchParams(window.location.search);
            const login = urlParams.get('login') || localStorage.getItem('currentUser');
            
            if (!login) {
                showMessage('NO USER SESSION FOUND', 'error');
                setTimeout(() => {
                    window.location.href = 'index.html';
                }, 2000);
                return;
            }

            try {
                const userDoc = await window.firebase.getDoc(window.firebase.doc(window.firebase.db, 'users', login));
                if (!userDoc.exists()) {
                    showMessage('USER DATA NOT FOUND', 'error');
                    return;
                }

                currentUser = { login, ...userDoc.data() };

                if (currentUser.role !== 'admin') {
                    showMessage('INSUFFICIENT PRIVILEGES', 'error');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 2000);
                    return;
                }

                document.getElementById('backToDashboard').href = `admin-dashboard.html?login=${login}`;
            } catch (error) {
                console.error('Error loading data:', error);
                showMessage('DATABASE CONNECTION ERROR', 'error');
            }
        }

        function initializeEditor() {
            setupEventListeners();
            loadTreeData();
        }

        function setupEventListeners() {
            // Tree tab switching
            document.getElementById('treeTabs').addEventListener('click', function(e) {
                if (e.target.classList.contains('tree-tab')) {
                    switchTree(e.target.dataset.tree);
                }
            });

            // Node palette drag and drop
            setupDragAndDrop();
            setupCanvasEvents();
        }

        function setupDragAndDrop() {
            document.querySelectorAll('.node-template').forEach(template => {
                // Click to select node type for placement
                template.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Deselect all templates
                    document.querySelectorAll('.node-template').forEach(t => t.classList.remove('selected'));
                    
                    // Select this template
                    this.classList.add('selected');
                    selectedNodeType = {
                        type: this.dataset.type,
                        size: parseInt(this.dataset.size)
                    };
                    
                    showMessage('Click on a grid cell to place the node', 'success');
                    
                    // Enable click-to-place on grid cells
                    enableGridClickToPlace();
                });

                // Drag and drop functionality (with text selection fix)
                template.addEventListener('dragstart', function(e) {
                    const nodeData = {
                        type: this.dataset.type,
                        size: parseInt(this.dataset.size)
                    };
                    selectedNodeType = nodeData;
                    e.dataTransfer.setData('text/plain', JSON.stringify(nodeData));
                    e.dataTransfer.effectAllowed = 'copy';
                    
                    // Prevent text selection during drag
                    document.body.style.userSelect = 'none';
                });

                template.addEventListener('dragend', function(e) {
                    selectedNodeType = null;
                    // Restore text selection
                    document.body.style.userSelect = '';
                });
                
                // Prevent text selection on mousedown
                template.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                });
            });
        }

        function setupCanvasEvents() {
            const tierContainer = document.getElementById('tierContainer');
            
            tierContainer.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            });

            tierContainer.addEventListener('drop', function(e) {
                e.preventDefault();
                handleNodeDrop(e);
            });

            tierContainer.addEventListener('click', function(e) {
                // Handle skill node selection
                if (e.target.classList.contains('skill-node') || e.target.closest('.skill-node')) {
                    const node = e.target.classList.contains('skill-node') ? e.target : e.target.closest('.skill-node');
                    selectNode(node);
                    return;
                }
                
                // Handle grid cell clicks - check if it's a clickable grid cell first
                if (e.target.classList.contains('grid-cell') && e.target.classList.contains('clickable')) {
                    // Let the grid cell's own click handler manage this
                    return;
                }
                
                // Handle empty space clicks
                if (!e.target.classList.contains('grid-cell')) {
                    if (selectedNodeType) {
                        clearNodeSelection();
                    } else {
                        deselectNode();
                    }
                }
            });
        }

        function switchTree(treeType) {
            // Save current tree before switching
            if (currentTree && treeData.tiers) {
                saveTreeData();
            }

            currentTree = treeType;
            
            // Update active tab
            document.querySelectorAll('.tree-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tree="${treeType}"]`).classList.add('active');
            
            // Update canvas title
            document.getElementById('canvasTitle').textContent = treeType.toUpperCase() + ' TREE';
            
            // Reset state
            selectedNode = null;
            connectingFrom = null;
            setTool('select');
            
            // Load tree data
            loadTreeData();
        }

        async function loadTreeData() {
            try {
                const treeId = `${currentTree}_tree`;
                const treeDoc = await window.firebase.getDoc(window.firebase.doc(window.firebase.db, 'skillTrees', treeId));
                
                if (treeDoc.exists()) {
                    treeData = treeDoc.data();
                } else {
                    // Initialize empty tree starting with tier 1
                    treeData = {
                        id: treeId,
                        name: `${currentTree.charAt(0).toUpperCase() + currentTree.slice(1)} Tree`,
                        associatedStat: currentTree,
                        tiers: []
                    };
                    
                    // Create tier 1 with starter node
                    const tier1 = createEmptyTier(1);
                    const starterNode = createStarterNode();
                    tier1.nodes.push(starterNode);
                    markGridCells(tier1, starterNode, true);
                    treeData.tiers.push(tier1);
                }
                
                renderTree();
                
            } catch (error) {
                console.error('Error loading tree:', error);
                showMessage('ERROR LOADING TREE DATA', 'error');
            }
        }

        function createStarterNode() {
            const nodeId = `${currentTree}_starter_${Date.now()}`;
            return {
                id: nodeId,
                type: 'small',
                tierNumber: 1,
                gridRow: 9, // Bottom of grid (last row)
                gridCol: 5, // Centered horizontally (middle column in 11-column grid: 0,1,2,3,4,5,6,7,8,9,10)
                gridSize: 1,
                name: `${currentTree.toUpperCase()} START`,
                description: `Starting node for ${currentTree} skill tree`,
                cost: 0,
                maxPurchases: 1,
                prerequisites: [],
                exclusions: [],
                connections: [],
                isStarter: true,
                statBonus: 'START'
            };
        }

        function createEmptyTier(tierNumber) {
            return {
                tier: tierNumber,
                requiredNodes: Math.max(0, tierNumber - 1),
                nodes: [],
                grid: createEmptyGrid()
            };
        }

        function createEmptyGrid() {
            const grid = {};
            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    grid[`${row}-${col}`] = null; // null = empty, nodeId = occupied
                }
            }
            return grid;
        }

        function renderTree() {
            const tierContainer = document.getElementById('tierContainer');
            tierContainer.innerHTML = '';

            if (!treeData.tiers || treeData.tiers.length === 0) {
                // Initialize with tier 1 containing starter node
                const tier1 = createEmptyTier(1);
                const starterNode = createStarterNode();
                tier1.nodes.push(starterNode);
                markGridCells(tier1, starterNode, true);
                treeData.tiers = [tier1];
            }

            // Render tiers from top to bottom (highest tier first, then descending to 1)
            const sortedTiers = [...treeData.tiers].sort((a, b) => b.tier - a.tier);

            sortedTiers.forEach(tier => {
                const tierElement = createTierElement(tier);
                tierContainer.appendChild(tierElement);
            });

            renderConnections();
        }

        function createTierElement(tier) {
            const tierDiv = document.createElement('div');
            tierDiv.className = 'tier-section';
            tierDiv.dataset.tier = tier.tier;

            // Tier content wrapper for centering
            const tierContent = document.createElement('div');
            tierContent.className = 'tier-content';

            // Tier header
            const header = document.createElement('div');
            header.className = 'tier-header';
            header.textContent = `TIER ${tier.tier}`;
            tierContent.appendChild(header);

            // Grid overlay 
            if (gridVisible) {
                const gridOverlay = createGridOverlay(tier);
                tierContent.appendChild(gridOverlay);
            }

            // Add nodes
            if (tier.nodes && tier.nodes.length > 0) {
                tier.nodes.forEach(node => {
                    const nodeElement = createNodeElement(node, tier.tier);
                    tierContent.appendChild(nodeElement);
                });
            }

            tierDiv.appendChild(tierContent);
            return tierDiv;
        }

        function createGridOverlay(tier) {
            const overlay = document.createElement('div');
            overlay.className = 'grid-overlay';

            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.style.left = (col * GRID_SIZE) + 'px';
                    cell.style.top = (row * GRID_SIZE) + 'px';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Mark occupied cells
                    const cellKey = `${row}-${col}`;
                    if (tier.grid && tier.grid[cellKey]) {
                        cell.classList.add('occupied');
                    }
                    
                    overlay.appendChild(cell);
                }
            }

            return overlay;
        }

        function createNodeElement(node, tierNumber) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = `skill-node node-${node.type}`;
            if (node.isStarter) {
                nodeDiv.classList.add('starter-node');
            }
            nodeDiv.dataset.nodeId = node.id;
            nodeDiv.dataset.tier = tierNumber;
            
            // Position based on grid coordinates
            nodeDiv.style.left = (node.gridCol * GRID_SIZE) + 'px';
            nodeDiv.style.top = (node.gridRow * GRID_SIZE) + 'px';
            
            // Set content based on node type
            if (node.type === 'small') {
                nodeDiv.textContent = node.statBonus || (node.isStarter ? 'START' : '+1');
            } else if (node.type === 'small-segmented-2') {
                nodeDiv.innerHTML = createSegmentedContent(node, 2);
            } else if (node.type === 'small-segmented-4') {
                nodeDiv.innerHTML = createSegmentedContent(node, 4);
            } else {
                nodeDiv.innerHTML = `
                    <div style="font-weight: 600; font-size: 10px;">${node.name || 'New Node'}</div>
                    ${node.description ? `<div style="font-size: 8px; opacity: 0.8;">${node.description.substring(0, 20)}${node.description.length > 20 ? '...' : ''}</div>` : ''}
                `;
            }

            return nodeDiv;
        }

        function createSegmentedContent(node, segments) {
            let html = '<div class="node-segmented">';
            
            if (segments === 2) {
                html += `
                    <div class="segment segment-2 left" style="background: ${getStatColor(node.stats?.[0] || 'STR')};">${node.stats?.[0] || 'STR'}</div>
                    <div class="segment segment-2 right" style="background: ${getStatColor(node.stats?.[1] || 'VIT')};">${node.stats?.[1] || 'VIT'}</div>
                `;
            } else if (segments === 4) {
                html += `
                    <div class="segment segment-4 top-left" style="background: ${getStatColor(node.stats?.[0] || 'STR')};">${node.stats?.[0] || 'STR'}</div>
                    <div class="segment segment-4 top-right" style="background: ${getStatColor(node.stats?.[1] || 'VIT')};">${node.stats?.[1] || 'VIT'}</div>
                    <div class="segment segment-4 bottom-left" style="background: ${getStatColor(node.stats?.[2] || 'SPD')};">${node.stats?.[2] || 'SPD'}</div>
                    <div class="segment segment-4 bottom-right" style="background: ${getStatColor(node.stats?.[3] || 'DEF')};">${node.stats?.[3] || 'DEF'}</div>
                `;
            }
            
            html += '</div>';
            return html;
        }

        function getStatColor(stat) {
            const colors = {
                'STR': '#ef4444',
                'VIT': '#10b981',
                'SPD': '#3b82f6',
                'DEF': '#f59e0b',
                'RAS': '#8b5cf6',
                'BUJ': '#ec4899',
                'WEP': '#06b6d4',
                'TSH': '#84cc16',
                'RYK': '#f97316'
            };
            return colors[stat] || '#64748b';
        }

        function enableGridClickToPlace() {
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.add('clickable');
                cell.onclick = function(e) {
                    e.stopPropagation(); // Prevent event bubbling
                    
                    if (!selectedNodeType) return;
                    
                    const tierElement = this.closest('.tier-section');
                    if (!tierElement) return;
                    
                    const tierNumber = parseInt(tierElement.dataset.tier);
                    const row = parseInt(this.dataset.row);
                    const col = parseInt(this.dataset.col);
                    
                    // Don't allow placing nodes exactly on the starter node position in tier 1
                    if (tierNumber === 1 && row === 9 && col === 5) {
                        showMessage('Cannot place node on starter position', 'error');
                        return;
                    }
                    
                    if (canPlaceNode(tierNumber, row, col, selectedNodeType)) {
                        createNewNode(selectedNodeType, tierNumber, row, col);
                        clearNodeSelection();
                    } else {
                        showMessage('Cannot place node here - space occupied or out of bounds', 'error');
                    }
                };
            });
        }

        function clearNodeSelection() {
            selectedNodeType = null;
            document.querySelectorAll('.node-template').forEach(t => t.classList.remove('selected'));
            document.querySelectorAll('.grid-cell').forEach(cell => {
                cell.classList.remove('clickable');
                cell.onclick = null;
            });
        }

        function getCellsForNode(gridRow, gridCol, nodeData) {
            const { type, size } = nodeData;
            let cells = [];

            if (size === 1) {
                cells = [`${gridRow}-${gridCol}`];
            } else if (size === 2) {
                cells = [`${gridRow}-${gridCol}`, `${gridRow}-${gridCol + 1}`];
            } else if (size === 4) {
                if (type === 'large-circle') {
                    // 2x2 square
                    cells = [
                        `${gridRow}-${gridCol}`,
                        `${gridRow}-${gridCol + 1}`,
                        `${gridRow + 1}-${gridCol}`,
                        `${gridRow + 1}-${gridCol + 1}`
                    ];
                } else {
                    // 4x1 rectangle
                    cells = [
                        `${gridRow}-${gridCol}`,
                        `${gridRow}-${gridCol + 1}`,
                        `${gridRow}-${gridCol + 2}`,
                        `${gridRow}-${gridCol + 3}`
                    ];
                }
            }

            return cells;
        }

        function handleNodeDrop(e) {
            const tierElement = e.target.closest('.tier-section');
            if (!tierElement) return;

            const tierContent = tierElement.querySelector('.tier-content');
            if (!tierContent) return;

            const tierNumber = parseInt(tierElement.dataset.tier);

            try {
                const nodeDataStr = e.dataTransfer.getData('text/plain');
                if (!nodeDataStr) return;
                
                const nodeData = JSON.parse(nodeDataStr);
                const rect = tierContent.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const gridCol = Math.floor(x / GRID_SIZE);
                const gridRow = Math.floor(y / GRID_SIZE);
                
                // Don't allow placing nodes on starter node position in tier 1
                if (tierNumber === 1 && gridRow === 9 && gridCol === 5) {
                    showMessage('Cannot place node on starter position', 'error');
                    return;
                }
                
                if (gridCol >= 0 && gridCol < GRID_COLS && gridRow >= 0 && gridRow < GRID_ROWS) {
                    if (canPlaceNode(tierNumber, gridRow, gridCol, nodeData)) {
                        createNewNode(nodeData, tierNumber, gridRow, gridCol);
                    } else {
                        showMessage('Cannot place node here - space occupied or out of bounds', 'error');
                    }
                }
            } catch (error) {
                console.error('Error handling drop:', error);
                showMessage('Error creating node', 'error');
            }
        }

        function canPlaceNode(tierNumber, gridRow, gridCol, nodeData) {
            const tier = treeData.tiers.find(t => t.tier === tierNumber);
            if (!tier || !tier.grid) return false;

            const cellsToCheck = getCellsForNode(gridRow, gridCol, nodeData);
            
            return cellsToCheck.every(cellKey => {
                const [row, col] = cellKey.split('-').map(Number);
                return row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS && !tier.grid[cellKey];
            });
        }

        function createNewNode(nodeData, tierNumber, gridRow, gridCol) {
            const nodeId = `${currentTree}_${tierNumber}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
            
            const newNode = {
                id: nodeId,
                type: nodeData.type,
                tierNumber: tierNumber,
                gridRow: gridRow,
                gridCol: gridCol,
                gridSize: nodeData.size,
                name: `New ${nodeData.type} Node`,
                description: '',
                cost: 1,
                maxPurchases: 1,
                prerequisites: [],
                exclusions: [],
                connections: [],
                isStarter: false
            };

            // Add type-specific properties
            if (nodeData.type.includes('small')) {
                if (nodeData.type.includes('segmented')) {
                    const segmentCount = nodeData.type.includes('4') ? 4 : 2;
                    newNode.stats = new Array(segmentCount).fill('STR');
                } else {
                    newNode.statBonus = '+1 ' + currentTree.substring(0, 3).toUpperCase();
                }
            }

            // Find tier and add node
            let tier = treeData.tiers.find(t => t.tier === tierNumber);
            if (!tier) {
                tier = createEmptyTier(tierNumber);
                treeData.tiers.push(tier);
            }

            tier.nodes.push(newNode);
            
            // Mark grid cells as occupied
            markGridCells(tier, newNode, true);
            
            renderTree();
            showMessage(`Created ${nodeData.type} node in tier ${tierNumber}`, 'success');
        }

        function markGridCells(tier, node, occupied) {
            const cellsToMark = getCellsForNode(node.gridRow, node.gridCol, {
                type: node.type,
                size: node.gridSize
            });

            cellsToMark.forEach(cellKey => {
                tier.grid[cellKey] = occupied ? node.id : null;
            });
        }

        function selectNode(nodeElement) {
            // Deselect all nodes
            document.querySelectorAll('.skill-node').forEach(node => {
                node.classList.remove('selected');
            });

            // Select this node
            nodeElement.classList.add('selected');
            selectedNode = nodeElement;

            // Show properties
            showNodeProperties(nodeElement);
        }

        function deselectNode() {
            if (selectedNode) {
                selectedNode.classList.remove('selected');
                selectedNode = null;
                showNodeProperties(null);
            }
        }

        function showNodeProperties(nodeElement) {
            const content = document.getElementById('propertiesContent');
            
            if (!nodeElement) {
                content.innerHTML = `
                    <div style="text-align: center; color: #64748b; font-family: 'JetBrains Mono', monospace; font-size: 12px; margin-top: 40px;">
                        SELECT A NODE TO EDIT
                    </div>
                `;
                return;
            }

            const nodeId = nodeElement.dataset.nodeId;
            const tier = parseInt(nodeElement.dataset.tier);
            const nodeData = findNodeData(nodeId, tier);

            if (!nodeData) return;

            let html = `
                <div class="form-group">
                    <label class="form-label">Node ID</label>
                    <input type="text" class="form-input" value="${nodeData.id}" readonly>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Type</label>
                    <input type="text" class="form-input" value="${nodeData.type}" readonly>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Name</label>
                    <input type="text" class="form-input" value="${nodeData.name || ''}" onchange="updateNodeProperty('${nodeId}', 'name', this.value)">
                </div>
                
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-textarea" onchange="updateNodeProperty('${nodeId}', 'description', this.value)">${nodeData.description || ''}</textarea>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Cost</label>
                    <input type="number" class="form-input" value="${nodeData.cost || 1}" min="0" onchange="updateNodeProperty('${nodeId}', 'cost', parseInt(this.value))">
                </div>
            `;

            // Add stat bonus for simple nodes
            if (nodeData.type === 'small' && !nodeData.type.includes('segmented')) {
                html += `
                    <div class="form-group">
                        <label class="form-label">Stat Bonus</label>
                        <input type="text" class="form-input" value="${nodeData.statBonus || ''}" onchange="updateNodeProperty('${nodeId}', 'statBonus', this.value)" placeholder="+1 STR">
                    </div>
                `;
            }

            // Add segmented stats for segmented nodes
            if (nodeData.type.includes('small') && nodeData.type.includes('segmented')) {
                html += `<div class="form-group">
                    <label class="form-label">Stat Types</label>`;
                
                const segmentCount = nodeData.type.includes('4') ? 4 : 2;
                for (let i = 0; i < segmentCount; i++) {
                    html += `
                        <select class="form-select" style="margin-bottom: 4px;" onchange="updateNodeStat('${nodeId}', ${i}, this.value)">
                            <option value="STR" ${nodeData.stats?.[i] === 'STR' ? 'selected' : ''}>STR - Strength</option>
                            <option value="VIT" ${nodeData.stats?.[i] === 'VIT' ? 'selected' : ''}>VIT - Vitality</option>
                            <option value="SPD" ${nodeData.stats?.[i] === 'SPD' ? 'selected' : ''}>SPD - Speed</option>
                            <option value="DEF" ${nodeData.stats?.[i] === 'DEF' ? 'selected' : ''}>DEF - Defense</option>
                            <option value="RAS" ${nodeData.stats?.[i] === 'RAS' ? 'selected' : ''}>RAS - Reiatsu</option>
                            <option value="BUJ" ${nodeData.stats?.[i] === 'BUJ' ? 'selected' : ''}>BUJ - Bujutsu</option>
                            <option value="WEP" ${nodeData.stats?.[i] === 'WEP' ? 'selected' : ''}>WEP - Weaponry</option>
                            <option value="TSH" ${nodeData.stats?.[i] === 'TSH' ? 'selected' : ''}>TSH - Tamashi</option>
                            <option value="RYK" ${nodeData.stats?.[i] === 'RYK' ? 'selected' : ''}>RYK - Reiryoku</option>
                        </select>
                    `;
                }
                html += `</div>`;
            }

            // Don't show delete button for starter nodes
            if (!nodeData.isStarter) {
                html += `
                    <div style="margin-top: 20px;">
                        <button class="btn btn-danger" onclick="deleteNode('${nodeId}', ${tier})">DELETE NODE</button>
                    </div>
                `;
            }

            content.innerHTML = html;
        }

        function findNodeData(nodeId, tierNumber) {
            const tier = treeData.tiers.find(t => t.tier === tierNumber);
            return tier?.nodes.find(node => node.id === nodeId);
        }

        function updateNodeProperty(nodeId, property, value) {
            const tierNumber = parseInt(selectedNode.dataset.tier);
            const nodeData = findNodeData(nodeId, tierNumber);
            
            if (nodeData) {
                nodeData[property] = value;
                renderTree();
                // Re-select the node to maintain selection
                setTimeout(() => {
                    const updatedNode = document.querySelector(`[data-node-id="${nodeId}"]`);
                    if (updatedNode) {
                        selectNode(updatedNode);
                    }
                }, 100);
            }
        }

        function updateNodeStat(nodeId, index, stat) {
            const tierNumber = parseInt(selectedNode.dataset.tier);
            const nodeData = findNodeData(nodeId, tierNumber);
            
            if (nodeData) {
                if (!nodeData.stats) nodeData.stats = [];
                nodeData.stats[index] = stat;
                renderTree();
                // Re-select the node to maintain selection
                setTimeout(() => {
                    const updatedNode = document.querySelector(`[data-node-id="${nodeId}"]`);
                    if (updatedNode) {
                        selectNode(updatedNode);
                    }
                }, 100);
            }
        }

        function deleteNode(nodeId, tierNumber) {
            if (confirm('Delete this node?')) {
                const tier = treeData.tiers.find(t => t.tier === tierNumber);
                if (tier) {
                    const nodeIndex = tier.nodes.findIndex(node => node.id === nodeId);
                    if (nodeIndex >= 0) {
                        const node = tier.nodes[nodeIndex];
                        
                        // Don't delete starter nodes
                        if (node.isStarter) {
                            showMessage('Cannot delete starter node', 'error');
                            return;
                        }
                        
                        // Free grid cells
                        markGridCells(tier, node, false);
                        
                        // Remove node
                        tier.nodes.splice(nodeIndex, 1);
                        
                        deselectNode();
                        renderTree();
                        showMessage('Node deleted', 'success');
                    }
                }
            }
        }

        function addTier() {
            const maxTier = Math.max(...treeData.tiers.map(t => t.tier), 0);
            const newTierNumber = maxTier + 1;
            const newTier = createEmptyTier(newTierNumber);
            treeData.tiers.push(newTier);
            renderTree();
            showMessage(`Added Tier ${newTierNumber}`, 'success');
        }

        function clearTier() {
            if (selectedNode) {
                const tierNumber = parseInt(selectedNode.dataset.tier);
                if (tierNumber === 1) {
                    showMessage('Cannot clear starter tier completely', 'error');
                    return;
                }
                
                if (confirm(`Clear Tier ${tierNumber} of all nodes?`)) {
                    const tier = treeData.tiers.find(t => t.tier === tierNumber);
                    if (tier) {
                        // Free all grid cells
                        tier.nodes.forEach(node => {
                            markGridCells(tier, node, false);
                        });
                        
                        // Clear nodes
                        tier.nodes = [];
                        
                        deselectNode();
                        renderTree();
                        showMessage(`Tier ${tierNumber} cleared`, 'success');
                    }
                }
            } else {
                showMessage('Select a node in the tier you want to clear', 'error');
            }
        }

        function resetTree() {
            if (confirm('Reset entire tree? This will delete all nodes except the starter.')) {
                // Keep tier 1 with starter node but reset all others
                const tier1 = treeData.tiers.find(t => t.tier === 1);
                if (tier1) {
                    // Keep only the starter node in tier 1
                    const starterNode = tier1.nodes.find(node => node.isStarter);
                    if (starterNode) {
                        tier1.nodes = [starterNode];
                        // Reset grid and mark starter position
                        tier1.grid = createEmptyGrid();
                        markGridCells(tier1, starterNode, true);
                        treeData.tiers = [tier1, createEmptyTier(2)];
                    } else {
                        // Recreate tier 1 with starter node
                        const newTier1 = createEmptyTier(1);
                        const starterNode = createStarterNode();
                        newTier1.nodes.push(starterNode);
                        markGridCells(newTier1, starterNode, true);
                        treeData.tiers = [newTier1, createEmptyTier(2)];
                    }
                } else {
                    // Recreate tier 1 with starter node
                    const newTier1 = createEmptyTier(1);
                    const starterNode = createStarterNode();
                    newTier1.nodes.push(starterNode);
                    markGridCells(newTier1, starterNode, true);
                    treeData.tiers = [newTier1, createEmptyTier(2)];
                }
                
                deselectNode();
                clearNodeSelection();
                renderTree();
                showMessage('Tree reset', 'success');
            }
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const toolButtons = document.querySelectorAll('.tool-btn');
            toolButtons.forEach(btn => {
                if (btn.textContent.toLowerCase().includes(tool.toLowerCase())) {
                    btn.classList.add('active');
                }
            });
            
            showMessage(`Tool: ${tool.toUpperCase()}`, 'success');
        }

        function toggleGrid() {
            gridVisible = !gridVisible;
            renderTree();
            showMessage(`Grid ${gridVisible ? 'enabled' : 'disabled'}`, 'success');
        }

        function renderConnections() {
            const svg = document.getElementById('connectionSvg');
            svg.innerHTML = '';
            // Connection rendering will be implemented in a future update
        }

        function previewTree() {
            showMessage('Preview functionality will be added in a future update', 'success');
        }

        async function saveTree() {
            try {
                showMessage('Saving tree...', 'success');
                const treeId = `${currentTree}_tree`;
                await window.firebase.setDoc(window.firebase.doc(window.firebase.db, 'skillTrees', treeId), treeData);
                showMessage('Tree saved successfully', 'success');
            } catch (error) {
                console.error('Error saving:', error);
                showMessage('Error saving tree', 'error');
            }
        }

        async function saveTreeData() {
            if (!currentUser || !treeData.tiers) return;
            try {
                const treeId = `${currentTree}_tree`;
                await window.firebase.setDoc(window.firebase.doc(window.firebase.db, 'skillTrees', treeId), treeData);
            } catch (error) {
                console.error('Auto-save error:', error);
            }
        }

        function exportTree() {
            const dataStr = JSON.stringify(treeData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `${currentTree}_skill_tree.json`;
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            showMessage('Tree exported', 'success');
        }

        function importTree() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            treeData = importedData;
                            renderTree();
                            showMessage('Tree imported successfully', 'success');
                        } catch (error) {
                            showMessage('Invalid JSON file', 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }

        function logout() {
            localStorage.removeItem('currentUser');
            window.location.href = 'index.html';
        }
    </script>
</body>
</html>